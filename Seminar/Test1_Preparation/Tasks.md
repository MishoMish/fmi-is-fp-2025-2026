# Подготовка за Тест 1

## Обхват: Седмици 1 - 6

| Тема                    | Седмица | Ключови концепции                                              |
| ----------------------- | ------- | -------------------------------------------------------------- | -------------- |
| Въведение               | 1       | GHCi, типове, `if-then-else`, `let`/`where`                    |
| Образци и гардове       | 2       | Pattern matching, guards, кортежи                              |
| Рекурсия                | 3       | Числова рекурсия, списъчна рекурсия, опашкова рекурсия         |
| Списъци                 | 4       | `(:)`, `head`/`tail`, `take`/`drop`, ranges, `String = [Char]` |
| Функции от по-висок ред | 5       | `map`, `filter`, `foldr`, `foldl`                              |
| Ламбди и comprehensions | 6       | `\x -> ...`, `(.)`, `($)`, `[x                                 | x <- xs, p x]` |

---

## Задача 1: Рекурсия и списъци

Напишете функция `pack :: Eq a => [a] -> [[a]]`, която групира последователни еднакви елементи:

```haskell
>>> pack [1,1,2,2,2,3,1,1]
[[1,1],[2,2,2],[3],[1,1]]
```

---

## Задача 2: HOF

Реализирайте `map`, `filter` и `reverse` чрез `foldr`/`foldl`.

---

## Задача 3: List comprehension

Генерирайте всички тройки `(a, b, c)` от `[1..n]` такива, че `a^2 + b^2 == c^2` и `a <= b`.

---

## Задача 4: Композиция

Пренапишете в безточков стил:

```haskell
f xs = length (filter (> 10) (map (* 3) xs))
```

---

## Задача 5: Комплексна задача

Напишете функция `mostFrequent :: Ord a => [a] -> a`, която връща най-често срещания елемент. При еднаква честота - най-малкия.

---

## Задача 6: Foldr / Foldl

Проследете стъпка по стъпка оценяването на:

```haskell
foldr (-) 0 [1, 2, 3]
foldl (-) 0 [1, 2, 3]
```

---

## Задача 7: Типови сигнатури

Определете типовите сигнатури на:

```haskell
f1 x y = x + y
f2 xs = map (+1) xs
f3 f xs = filter f xs
f4 f g x = f (g x)
```
